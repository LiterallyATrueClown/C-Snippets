<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!--Khôi Nguyên Óc Cặc-->
<snippets>
    <item name="Công thức Euler" type="snippet" ID="1">
        <snippet>f64 EulerTotient(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;    f64 res = n;&#x0D;&#x0A;    for (f64 p = 2; p * p &lt;= n; p++)&#x0D;&#x0A;        if (n % p == 0)&#x0D;&#x0A;&#x09;&#x09;{&#x0D;&#x0A;            while (n % p == 0)&#x0D;&#x0A;                n /= p;&#x0D;&#x0A;            res -= res / p;&#x0D;&#x0A;        }&#x0D;&#x0A;    if (n &gt; 1)&#x0D;&#x0A;        res -= res / n;&#x0D;&#x0A;    return res;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Kiểm tra số Fibonacci" type="snippet" ID="2">
        <snippet>bool isFibonacci(f64 n) {&#x0D;&#x0A;    f64 x = 5 * n * n + 4;&#x0D;&#x0A;    f64 y = 5 * n * n - 4;&#x0D;&#x0A;    int rootX = sqrt(x);&#x0D;&#x0A;    f64 rootY = sqrt(y);&#x0D;&#x0A;    return (rootX * rootX == x) || (rootY * rootY == y);&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Kiểm tra số chính phương" type="snippet" ID="3">
        <snippet>bool isPerfectSquare(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;    f64 root = sqrt(n);&#x0D;&#x0A;    return (root * root == n);&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Kiểm tra số nguyên tố" type="snippet" ID="4">
        <snippet>bool isPrime(f64 n) {&#x0D;&#x0A;    if (n &lt;= 1 || n % 2 == 0 || n % 3 == 0)&#x0D;&#x0A;        return n == 2 || n == 3;&#x0D;&#x0A;    for (f64 i = 5; i * i &lt;= n; i += 6)&#x0D;&#x0A;        if (n % i == 0 || n % (i + 2) == 0)&#x0D;&#x0A;            return false;&#x0D;&#x0A;    return true;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Kiểm tra xâu đối xứng" type="snippet" ID="5">
        <snippet>// Kiểm tra tính đối xứng cả xâu&#x0D;&#x0A;bool isPalindrome(string s)&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;size_t n = s.size();&#x0D;&#x0A;&#x09;for (size_t i = 0; i &lt; n; i++)&#x0D;&#x0A;&#x09;&#x09;if (s[i] != s[n - i - 1])&#x0D;&#x0A;&#x09;&#x09;&#x09;return false;&#x0D;&#x0A;&#x09;return true;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;// Kiểm tra tính đối xứng của xâu trên đoạn từ left đến right&#x0D;&#x0A;bool isPalindrome(string s, f64 left, f64 right)&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;while (left &lt; right)&#x0D;&#x0A;&#x09;{&#x0D;&#x0A;&#x09;&#x09;if (s[left] != s[right])&#x0D;&#x0A;&#x09;&#x09;&#x09;return false;&#x0D;&#x0A;&#x09;&#x09;left++;&#x0D;&#x0A;&#x09;&#x09;right--;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x09;return true;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Lấy số Fibonacci thứ n" type="snippet" ID="6">
        <snippet>f64 Fibo(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;    if (n &lt;= 1)&#x0D;&#x0A;        return n;&#x0D;&#x0A;    return Fibo(n - 1) + Fibo(n - 2);&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Phân tích thừa số nguyên tố (Bước nhảy 6)" type="snippet" ID="7">
        <snippet>vector &lt;f64&gt; PTThuaSoNT(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;    vector &lt;f64&gt; factors;&#x0D;&#x0A;    while (n % 2 == 0)&#x0D;&#x0A;&#x09;{&#x0D;&#x0A;        factors.push_back(2);&#x0D;&#x0A;        n = n / 2;&#x0D;&#x0A;    }&#x0D;&#x0A;    while (n % 3 == 0)&#x0D;&#x0A;&#x09;{&#x0D;&#x0A;        factors.push_back(3);&#x0D;&#x0A;        n = n / 3;&#x0D;&#x0A;    }&#x0D;&#x0A;    for (f64 i = 5; i * i &lt;= n; i += 6)&#x0D;&#x0A;    {&#x0D;&#x0A;        while (n % i == 0)&#x0D;&#x0A;&#x09;&#x09;{&#x0D;&#x0A;            factors.push_back(i);&#x0D;&#x0A;            n = n / i;&#x0D;&#x0A;&#x09;&#x09;}&#x0D;&#x0A;        while (n % (i + 2) == 0)&#x0D;&#x0A;&#x09;&#x09;{&#x0D;&#x0A;            factors.push_back(i + 2);&#x0D;&#x0A;            n = n / (i + 2);&#x0D;&#x0A;        }&#x0D;&#x0A;    }&#x0D;&#x0A;    if (n &gt; 1)&#x0D;&#x0A;        factors.push_back(n);&#x0D;&#x0A;&#x09;return factors;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Setup code khởi đầu (full macro)" type="snippet" ID="8">
        <snippet>#include &lt;bits/stdc++.h&gt;&#x0D;&#x0A;#define f64 int_fast64_t&#x0D;&#x0A;#define optimize() ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);&#x0D;&#x0A;#define io(s) if (fopen(s&quot;.inp&quot;, &quot;r&quot;)) {freopen(s&quot;.inp&quot;, &quot;r&quot;, stdin); freopen(s&quot;.out&quot;, &quot;w&quot;, stdout);};&#x0D;&#x0A;#define f first&#x0D;&#x0A;#define s second&#x0D;&#x0A;#define um unordered_map&#x0D;&#x0A;#define us unordered_set&#x0D;&#x0A;#define v64 vector &lt;f64&gt;&#x0D;&#x0A;#define vchar vector &lt;char&gt;&#x0D;&#x0A;#define vstr vector &lt;string&gt;&#x0D;&#x0A;#define vp64 vector &lt;pair &lt;f64, f64&gt;&gt;&#x0D;&#x0A;#define endl &apos;\n&apos;&#x0D;&#x0A;#define Sizeof(x) ((f64) x.size())&#x0D;&#x0A;#define all(p) p.begin(), p.end()&#x0D;&#x0A;#define pb push_back&#x0D;&#x0A;#define mp make_pair&#x0D;&#x0A;#define p64 pair&lt;f64, f64&gt;&#x0D;&#x0A;#define s64 set&lt;f64&gt;&#x0D;&#x0A;#define rep(a, b) for(f64 i = a; i &lt; b; i++)&#x0D;&#x0A;#define repr(a, b) for(f64 i = a; i &gt;= b; i--)&#x0D;&#x0A;#define MOD 1000000007&#x0D;&#x0A;using namespace std;&#x0D;&#x0A;&#x0D;&#x0A;int main()&#x0D;&#x0A;{&#x09;&#x0D;&#x0A;&#x09;optimize();&#x0D;&#x0A;&#x09;io(&quot;&quot;);&#x0D;&#x0A;&#x09;return 0;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Sàng số Fibonacci" type="snippet" ID="9">
        <snippet>bool Fibo[20000003];&#x0D;&#x0A;&#x0D;&#x0A;void FiboDP()&#x0D;&#x0A;{&#x0D;&#x0A;    Fibo[0] = 0;&#x0D;&#x0A;    Fibo[1] = 1;&#x0D;&#x0A;    for (f64 i = 2; i &lt;= 20000003; i++)&#x0D;&#x0A;        Fibo[i] = Fibo[i - 1] + Fibo[i - 2];&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/* Code mẫu:&#x0D;&#x0A;int main()&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;FiboDP()&#x0D;&#x0A;&#x09;int n;&#x0D;&#x0A;&#x09;cin &gt;&gt; n;&#x0D;&#x0A;&#x09;cout &lt;&lt; &quot;Số fibonacci thứ n là: &quot; &lt;&lt; Fibo[n];&#x0D;&#x0A;&#x09;return 0;&#x0D;&#x0A;}&#x0D;&#x0A;*/</snippet>
    </item>
    <item name="Sàng số nguyên tố (Atkin)" type="snippet" ID="10">
        <snippet>bool isPrime[20000003];&#x0D;&#x0A;&#x0D;&#x0A;void sieve()&#x0D;&#x0A;{&#x0D;&#x0A;    isPrime[2] = isPrime[3] = true;&#x0D;&#x0A;    for (f64 x = 1; x * x &lt;= 20000003; x++)&#x0D;&#x0A;        for (f64 y = 1; y * y &lt;= 20000003; y++)&#x0D;&#x0A;&#x09;&#x09;{&#x0D;&#x0A;            f64 n = (4 * x * x) + (y * y);&#x0D;&#x0A;            if (n &lt;= 20000003 &amp;&amp; (n % 12 == 1 || n % 12 == 5))&#x0D;&#x0A;                isPrime[n] ^= true;&#x0D;&#x0A;            n = (3 * x * x) + (y * y);&#x0D;&#x0A;            if (n &lt;= 20000003 &amp;&amp; n % 12 == 7)&#x0D;&#x0A;                isPrime[n] ^= true;&#x0D;&#x0A;            n = (3 * x * x) - (y * y);&#x0D;&#x0A;            if (x &gt; y &amp;&amp; n &lt;= 20000003 &amp;&amp; n % 12 == 11)&#x0D;&#x0A;                isPrime[n] ^= true;&#x0D;&#x0A;        }&#x0D;&#x0A;    for (f64 r = 5; r * r &lt;= 20000003; r++)&#x0D;&#x0A;        if (isPrime[r] == true)&#x0D;&#x0A;            for (f64 i = r * r; i &lt;= 20000003; i += r * r)&#x0D;&#x0A;&#x09;&#x09;&#x09;&#x09;isPrime[i] = false;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/* Code mẫu:&#x0D;&#x0A;int main()&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;sieve()&#x0D;&#x0A;&#x09;int n;&#x0D;&#x0A;&#x09;cin &gt;&gt; n;&#x0D;&#x0A;&#x09;if (isPrime[n] == true)&#x0D;&#x0A;&#x09;&#x09;cout &lt;&lt; &quot;N là số nguyên tố&quot;;&#x0D;&#x0A;&#x09;else&#x0D;&#x0A;&#x09;&#x09;cout &lt;&lt; &quot;N đéo phải là số nguyên tố&quot;&#x0D;&#x0A;&#x09;return 0;&#x0D;&#x0A;}&#x0D;&#x0A;*/</snippet>
    </item>
    <item name="Sàng số nguyên tố (Eratosthene)" type="snippet" ID="11">
        <snippet>bool isPrime[20000003];&#x0D;&#x0A;&#x0D;&#x0A;void sieve()&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;isPrime[0] = isPrime[1] = true;&#x0D;&#x0A;    for (f64 i = 2; i * i &lt;= 20000002; i++)&#x0D;&#x0A;         if (isPrime[i] == false)&#x0D;&#x0A;             for(f64 j = i * i; j &lt;= 20000002; j += i)&#x0D;&#x0A;                 isPrime[j] = true;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;/* Code mẫu:&#x0D;&#x0A;int main()&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;sieve()&#x0D;&#x0A;&#x09;int n;&#x0D;&#x0A;&#x09;cin &gt;&gt; n;&#x0D;&#x0A;&#x09;// Lưu ý, vì sàng này được khai báo false đầu tiên nên nếu isPrime[n] mà là false thì mới là số nguyên tố còn true là không phải&#x0D;&#x0A;&#x09;if (isPrime[n] == false)&#x0D;&#x0A;&#x09;&#x09;cout &lt;&lt; &quot;N là số nguyên tố&quot;;&#x0D;&#x0A;&#x09;else&#x0D;&#x0A;&#x09;&#x09;cout &lt;&lt; &quot;N đéo phải là số nguyên tố&quot;&#x0D;&#x0A;&#x09;return 0;&#x0D;&#x0A;}&#x0D;&#x0A;*/</snippet>
    </item>
    <item name="Tổng tất cả chữ số của một số" type="snippet" ID="12">
        <snippet>f64 sod(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;f64 sum = 0;&#x0D;&#x0A;&#x09;while (n)&#x0D;&#x0A;&#x09;{&#x0D;&#x0A;&#x09;&#x09;sum += n % 10;&#x0D;&#x0A;&#x09;&#x09;n /= 10;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x09;return sum;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Uớc/Bội Chung Lớn/Nhỏ Nhất" type="snippet" ID="13">
        <snippet>f64 gcd(f64 a, f64 b) {&#x0D;&#x0A;    while (b != 0) {&#x0D;&#x0A;        f64 temp = a;&#x0D;&#x0A;        a = b;&#x0D;&#x0A;        b = temp % b;&#x0D;&#x0A;    }&#x0D;&#x0A;    return a;&#x0D;&#x0A;}&#x0D;&#x0A;&#x0D;&#x0A;f64 lcm(f64 a, f64 b) {&#x0D;&#x0A;    return (a / gcd(a, b)) * b;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Đảo ngược số" type="snippet" ID="14">
        <snippet>f64 reversei(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;&#x09;if (n &lt; 10)&#x0D;&#x0A;&#x09;&#x09;return n;&#x0D;&#x0A;&#x09;f64 ans = 0;&#x0D;&#x0A;&#x09;while (n)&#x0D;&#x0A;&#x09;{&#x0D;&#x0A;&#x09;&#x09;ans += n % 10;&#x0D;&#x0A;&#x09;&#x09;ans *= 10;&#x0D;&#x0A;&#x09;&#x09;n /= 10;&#x0D;&#x0A;&#x09;}&#x0D;&#x0A;&#x09;return ans / 10;&#x0D;&#x0A;}</snippet>
    </item>
    <item name="Đếm ước" type="snippet" ID="15">
        <snippet>f64 demUoc(f64 n)&#x0D;&#x0A;{&#x0D;&#x0A;    f64 dem = 0;&#x0D;&#x0A;    for (f64 i = 1; i * i &lt;= n; i++)&#x0D;&#x0A;        if (n % i == 0)&#x0D;&#x0A;            if (n / i == i)&#x0D;&#x0A;                dem++;&#x0D;&#x0A;            else&#x0D;&#x0A;                dem += 2;&#x0D;&#x0A;    return dem;&#x0D;&#x0A;}&#x0D;&#x0A;</snippet>
    </item>
</snippets>
